## 项目介绍

基于哈夫曼编码实现文件解压、压缩功能。

### _include

* FileCompress.h
  * CodeInfo 类
    * 成员变量：字符、编码、字符出现频次
  * FileCompress 类
    * 成员变量：CodeInfo 类型的数组，存放每个字符的编码和频次
    * 成员方法：压缩、解压等相关方法
* Huffman.h
  * HuffmanTreeNode 类
  * HuffmanTree 类

### src

* FileCompress.cpp
* main.cpp

### 使用

* `make` 生成可执行文件
* `make run` 运行
* `make clean` 删除可执行文件、.o文件等



## Huffman树

### Huffman树的创建 

* 通过获取到文件中的 n 个字符及频次，构造 n 棵只有根节点的二叉树森林。
* 重复以下步骤，直到只剩下一棵树为止：
  * 选取两棵根节点的权值最小的二叉树，作为左右子树构造一棵新的二叉树。将新二叉树的根节点的权值为其左、右子树上根节点的权值之和
  * 删除这两棵二叉树
  * 把新的二叉树加入其中

> 由于每次要从森林中选取权重最小的两棵树，此处我采用堆（标准模板库中的优先级队列）进行处理。

### Huffman编码

在创建好的Huffman树中，左孩子标记 0，右孩子标记 1，从根节点遍历到某个叶子节点所产生的序列便是 Huffman 编码。

由这种方法得到的编码是**前缀编码**：任何一个字符的编码不是另一个字符编码的前缀，这样才能保证译码的唯一性。



## 主要功能实现

### 压缩

* 遍历待压缩文件，统计每个字符出现次数
* 创建Huffman树
* 获取Huffman编码
* 将解压缩必要信息保存到目标文件首部（以`'\n'`分隔）
  * 原文件扩展名
  * 后续字符行数
  * 字符与对应次数
  * 数据部分

* 按编码将对应字符转换（位运算）
  * 将原数据中每个字符转换成哈夫曼编码，凑够8位转换成字符存入压缩后的文件中，如果存在剩余的位数（不够8位），进行右移到8位再存入。

* 压缩生成 `.gx`文件

### 解压

* 获取待解压文件首部信息

* 通过获取的字符及出现次数创建Huffman树

* 解码
  * 用待解压文件中的内容以二进制方式从Huffman树根结点开始，0走左，1走右，遇到叶子节点，则获取到解压后的字符